#!/usr/bin/env ruby -W0

me = if File.symlink?(__FILE__)
  File.readlink(__FILE__)
else
  __FILE__
end

VIZR_ROOT =  File.expand_path("..", File.dirname(me))
WORKING_DIR = Dir.pwd

require 'rubygems'
require 'bundler/setup'
require 'rake'
require 'optparse'
require 'yaml'
require 'handlebars'

#disable fileutils verbosity
verbose(false)

load File.join(VIZR_ROOT, 'tasks/build.rb')
load File.join(VIZR_ROOT, 'tasks/dist.rb')
load File.join(VIZR_ROOT, 'tasks/upload.rb')

EMPTY_PROJECT_PATH = "./projects"
DOT_FILE = ".vizr"
LOCK_FILE = ".vizr-lock"
USER_FILE = "~/.vizrrc"

DEV_PATH = "./dev"
BUILD_PATH = "./build"
TMP_PATH = "./tmpbuild"

COMMANDS = {}

COMMANDS[:create] = Proc.new do |args|
  options = {
    :type => :basic
  }
  parser = OptionParser.new do |opts|
    opts.banner = "usage: vizr create [args] <projectpath>"

    opts.on("-t", "--type TYPE", [:basic], "Predefined project type (basic only offered now)") do |type|
      options[:type] = type.to_sym
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  parser.parse!(args)
  if args[0]
    src = File.join(File.expand_path(File.join(EMPTY_PROJECT_PATH, options[:type].to_s), VIZR_ROOT), ".")
    dest = File.expand_path(args[0], WORKING_DIR)
    cp_r(src, dest, {})
    touch(File.join(dest, DOT_FILE))
    sh "echo \"#{LOCK_FILE}\" >> \"#{File.join(dest, ".gitignore")}\""
  else
    puts parser
  end
end

COMMANDS[:build] = Proc.new do |args|
  options = {
    :minify => true
  }
  parser = OptionParser.new do |opts|
    opts.banner = "usage: vizr build [args] <projectpath>"

    opts.on("--no-minify", "Prevent asset minification if available")do
      options[:minify] = false
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  parser.parse!(args)
  setup_env(args) do |target, env|
    Rake::Task["build"].invoke(target, options)
  end
end

COMMANDS[:dist] = Proc.new do |args|
  options = {
    :filename => "dist.zip"
  }

  parser = OptionParser.new do |opts|
    opts.banner = "usage: vizr dist [args] <projectpath>"
    options[:name] = "dist.zip"
    opts.on("-n", "--filename [NAME]", "File name of zip (default: dist.zip)") do |filename|
      options[:filename] = filename
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  parser.parse!(args)
  setup_env(args) do |target, env|
    Rake::Task["package"].invoke(target, options)
  end
end

COMMANDS[:pull] = Proc.new do |args|
  pull = true
  parser = OptionParser.new do |opts|
    opts.banner = "Update vizr builder to new version\nusage: vizr pull [args]"

    opts.on_tail("-h", "--help", "Show this message") do
      pull = false
      puts opts
      exit
    end
  end

  parser.parse!(args)
  if pull
    cd(VIZR_ROOT)
    sh "git pull"
    sh "bundle install"
  else
    puts parser
  end
end

COMMANDS[:upload] = Proc.new do |args|
  options = {
    :filename => "dist.zip",
    :version_files => true
  }

  parser = OptionParser.new do |opts|
    opts.banner = "usage: vizr upload [args] <projectpath>"
    opts.on("-n", "--filename [NAME]", "File name of zip (default: dist.zip)") do |filename|
      options[:filename] = filename
    end

    opts.on("--[no-]version", "Version files (versioning allows web browsers to cache content)") do |version|
      options[:version_files] = version
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  parser.parse!(args)
  setup_env(args) do |target, env|
    options = env.update(options)
    Rake::Task["upload"].invoke(target, options)
  end
end

COMMANDS[:help] = Proc.new do |args|
  # handles case when someone enters in "vizr help <command>"
  if args[0] && COMMANDS[args[0].to_sym]
    parse_args(args[0].to_sym, ["-h"])
    exit
  end

  # max spaces to show between command and description
  spaces = 10

  # output info
  puts "usage: vizr <command> [<args>]\n\n"
  puts "vizr commands are:"
  [
    ["build", "build a vizr project"],
    ["create", "create a new vizr project"],
    ["dist", "zip up the contents of a project's build folder"],
    ["help", "this information"],
    ["pull", "update vizr builder to newest version"]
  ].each do |cmd|
    puts "   #{cmd[0]}#{" " * (spaces - cmd[0].length)}#{cmd[1]}"
  end
  puts "\nSee 'vizr help <command>' for more information on a specific command"
end


def setup_env(args, &block)
  if args[0]
    target = File.expand_path(args[0], WORKING_DIR)

    user_file = check_for_user_file()
    dot_file = check_for_dot_file(target)

    env = {}
    env.merge!(YAML.load_file(user_file)) if user_file
    env.merge!(YAML.load_file(dot_file)) if dot_file

    if dot_file && check_lock(target)
      block.call(target, env)
    end
  else
    puts parser
  end
end

def check_for_dot_file(target)
  dot_file = [DOT_FILE, ".vizer"].find do |file|
    File.exists?(File.join(target, file))
  end

  if dot_file
    File.join(target, dot_file)
  else
    message(:not_a_project, {
      :target => target
    })
    nil
  end
end

def check_for_user_file
  user_file = File.expand_path(USER_FILE)
  if File.exists?(user_file)
    user_file
  else
    nil
  end
end

def check_lock(target)
  ok = true
  found = false
  lock_path = File.join(target, LOCK_FILE)
  lock_paths_to_check = [LOCK_FILE, ".vizer-lock"]
  content = nil
  begin
    lock_paths_to_check.count do |path|
      path = File.join(target, path)
      found = File.exists?(path)
      if found
        content = File.read(path)
        ok = (content.strip == target.strip)
      end

      break if found && ok
    end

    unless found
      raise "Couldn't find file"
    end
  rescue
    # create lock file
    sh "echo \"#{target}\" > \"#{lock_path}\""

    # make sure lock file doesn't get checked in
    sh "echo \"#{LOCK_FILE}\" >> \"#{File.join(target, ".gitignore")}\""
  end

  if not ok
    message(:locked, {
      :copied_from => (content || "<empty file>").strip,
      :target => target.strip,
      :lock_file => LOCK_FILE
    })
    exit
  end

  ok
end

#TODO
def check_for_updates
  #git log -n 1 origin
end

def message(name, context)
  content = ""
  path = File.expand_path("messages/#{name.to_s}.hbs", VIZR_ROOT)
  File.open(path, "r") do |file|
    content = file.read
  end

  template = Handlebars.compile(content)
  puts ""
  puts template.call(context)
  puts ""
end

def parse_args(command_name, args)
  check_for_updates

  command_name = command_name || :help
  args = args || []
  command = COMMANDS[command_name] || COMMANDS[:help]

  command.call(args)
end

cmd = ARGV[0].to_sym rescue nil
parse_args(cmd, ARGV[1..-1])
