#!/usr/bin/env ruby -w

me = if File.symlink?(__FILE__)
  File.readlink(__FILE__)
else
  __FILE__
end

VIZER_ROOT =  File.expand_path("..", File.dirname(me))
WORKING_DIR = Dir.pwd

require 'rubygems'
require 'fileutils'
require 'rake'
require 'optparse'

include FileUtils

load File.join(VIZER_ROOT, 'tasks/build.rb')
load File.join(VIZER_ROOT, 'tasks/dist.rb')
load File.join(VIZER_ROOT, 'tasks/upload.rb')

EMPTY_PROJECT_PATH = "./projects"
DOT_FILE = ".vizr"
LOCK_FILE = ".vizr-lock"

DEV_PATH = "./dev"
BUILD_PATH = "./build"
TMP_PATH = "./tmpbuild"


COMMANDS = {}

COMMANDS[:create] = Proc.new do |args|
  options = {
    :type => :basic
  }
  parser = OptionParser.new do |opts|
    opts.banner = "usage: vizr create [args] <projectpath>"

    opts.on("-t", "--type TYPE", [:basic], "Predefined project type (basic only offered now)") do |type|
      options[:type] = type.to_sym
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  parser.parse!(args)
  if args[0]
    src = File.join(File.expand_path(File.join(EMPTY_PROJECT_PATH, options[:type].to_s), VIZER_ROOT), ".")
    dest = File.expand_path(args[0], WORKING_DIR)
    cp_r(src, dest, {})
    touch(File.join(dest, DOT_FILE))
    sh "echo \"#{LOCK_FILE}\" >> \"#{File.join(dest, ".gitignore")}\""
  else
    puts parser
  end
end

COMMANDS[:build] = Proc.new do |args|
  options = {
    :minify => true
  }
  parser = OptionParser.new do |opts|
    opts.banner = "usage: vizr build [args] <projectpath>"

    opts.on("--no-minify", "Prevent asset minification if available")do
      options[:minify] = false
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  parser.parse!(args)
  setup_env(args) do |target, env|
    Rake::Task["build"].invoke(target, options)
  end
end

COMMANDS[:dist] = Proc.new do |args|
  options = {
    :filename => "dist.zip"
  }

  parser = OptionParser.new do |opts|
    opts.banner = "usage: vizr dist [args] <projectpath>"
    options[:name] = "dist.zip"
    opts.on("-n", "--filename [NAME]", "File name of zip (default: dist.zip)") do |filename|
      options[:filename] = filename
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  parser.parse!(args)
  setup_env(args) do |target, env|
    Rake::Task["package"].invoke(target, options)
  end
end

COMMANDS[:pull] = Proc.new do |args|
  pull = true
  parser = OptionParser.new do |opts|
    opts.banner = "Update vizr builder to new version\nusage: vizr pull [args]"

    opts.on_tail("-h", "--help", "Show this message") do
      pull = false
      puts opts
      exit
    end
  end

  parser.parse!(args)
  if pull
    cd(VIZER_ROOT)
    sh "git pull"
  else
    puts parser
  end
end

COMMANDS[:upload] = Proc.new do |args|
  options = {
    :filename => "dist.zip",
    :version_files => true
  }

  parser = OptionParser.new do |opts|
    opts.banner = "usage: vizr upload [args] <projectpath>"
    opts.on("-n", "--filename [NAME]", "File name of zip (default: dist.zip)") do |filename|
      options[:filename] = filename
    end

    opts.on("--no-version", "Prevent server from versioning files (versioning allows web browsers to cache content)") do
      options[:version_files] = false
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  parser.parse!(args)
  setup_env(args) do |target, env|
    Rake::Task["upload"].invoke(target, options)
  end
end

COMMANDS[:help] = Proc.new do |args|
  # handles case when someone enters in "vizr help <command>"
  if args[0] && COMMANDS[args[0].to_sym]
    parse_args(args[0].to_sym, ["-h"])
    exit
  end

  # max spaces to show between command and description
  spaces = 10

  # output info
  puts "usage: vizr <command> [<args>]\n\n"
  puts "vizr commands are:"
  [
    ["build", "build a vizr project"],
    ["create", "create a new vizr project"],
    ["dist", "zip up the contents of a project's build folder"],
    ["help", "this information"],
    ["pull", "update vizr builder to newest version"]
  ].each do |cmd|
    puts "   #{cmd[0]}#{" " * (spaces - cmd[0].length)}#{cmd[1]}"
  end
  puts "\nSee 'vizr help <command>' for more information on a specific command"
end


def setup_env(args, &block)
  if args[0]
    target = File.expand_path(args[0], WORKING_DIR)

    if check_for_dot_file(target) && check_lock(target)
      block.call(target, {})
    end
  else
    puts parser
  end
end

def check_for_dot_file(target)
  dot_file = [DOT_FILE, ".vizer"].find do |file|
    File.exists?(File.join(target, file))
  end

  if dot_file
    File.join(target, dot_file)
  else
    puts "    Vizr problem"
    puts "================="
    puts "    Not a valid vizr path"
    puts "    All commands must be followed by a relative path to the root"
    puts "    of a vizr project"
    puts ""
    puts "================="
    puts "    Your target: #{target}"
    puts ""

    nil
  end
end

def check_lock(target)
  ok = true
  found = false
  lock_path = File.join(target, LOCK_FILE)
  lock_paths_to_check = [LOCK_FILE, ".vizer-lock"]
  begin
    found = lock_paths_to_check.count do |path|
      path = File.join(target, path)
      found = File.exists?(path)
      if found
        content = File.read(path)
        ok = (content.strip == target.strip)
      end

      break if found && ok
    end

  rescue
    # create lock file
    sh "echo \"#{target}\" > \"#{lock_path}\""

    # make sure lock file doesn't get checked in
    sh "echo \"#{LOCK_FILE}\" >> \"#{File.join(target, ".gitignore")}\""
  end

  if not ok
    puts "    Vizr problem"
    puts "================="
    puts "    It appears this directory was copied from another location."
    puts "    It is recommended that you create a new project from scratch"
    puts "    (see: `vizr help create`) in order ensure to you have up-to-date"
    puts "    project assets"
    puts ""
    puts "    If you want to prevent this check, please delete '#{LOCK_FILE}'"
    puts "    in the project root"
    puts ""
    puts "================="
    puts "    Original path:"
    puts "    #{content || ""}"
    puts ""
    puts "    Target path:"
    puts "    #{target}"
    puts ""
    exit
  end

  ok
end

#TODO
def check_for_updates
  #git log -n 1 origin
end

def parse_args(command_name, args)
  check_for_updates

  command_name = command_name || :help
  args = args || []
  command = COMMANDS[command_name] || COMMANDS[:help]

  command.call(args)
end

cmd = ARGV[0].to_sym rescue nil
parse_args(cmd, ARGV[1..-1])
